name: Build Windows Installer and Release

on:
  push:
    tags:
      - 'v*'
      ##uncomment this when releasing stable updates
    ##branches:
    ##- main
  workflow_dispatch:

jobs:
  build-and-release:
    runs-on: windows-latest

    steps:
      # 1. Checkout repo
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch all history for all branches and tags

      # 2. Cache OBS Studio
      - name: Cache OBS Studio
        id: cache-obs
        uses: actions/cache@v4
        with:
          path: obs
          key: obs-studio-31.0.3-${{ runner.os }}

      # 3. Download OBS if not cached
      - name: Download OBS if not cached
        if: steps.cache-obs.outcome != 'cache-hit'
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path obs
          Invoke-WebRequest -Uri https://github.com/obsproject/obs-studio/releases/download/31.0.3/OBS-Studio-31.0.3-Windows.zip -OutFile obs.zip
          Expand-Archive -Path obs.zip -DestinationPath obs -Force
          Remove-Item obs.zip

      # 4. Setup Node.js
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 14

      # 5. Setup MSBuild (for native modules)
      - name: Setup MSBuild
        uses: microsoft/setup-msbuild@v1.1

      # 6. Setup Visual Studio environment
      - name: Setup VS Build Environment
        shell: cmd
        run: |
          for /f "usebackq tokens=*" %%i in (`vswhere.exe -latest -products * -requires Microsoft.Component.MSBuild -property installationPath`) do (
            call "%%i\VC\Auxiliary\Build\vcvars64.bat"
          )

      # 7. Install node-gyp
      - name: Install node-gyp
        run: |
          npm install --global node-gyp@9.4.1
          npm config set node_gyp "$(npm prefix -g)\node_modules\node-gyp\bin\node-gyp.js"
          npm config set msvs_version 2022

      # 8. Install dependencies
      - name: Install dependencies
        working-directory: app
        env:
          PUPPETEER_SKIP_DOWNLOAD: false
        run: |
          npm ci --no-optional
          npx patch-package

      # 9. Verify puppeteer
      - name: Verify Puppeteer Installation
        working-directory: app
        run: node -e "console.log('Puppeteer path:', require.resolve('puppeteer')); const puppeteer = require('puppeteer'); console.log('Puppeteer loaded successfully');"

      # 9b. Install watchdog dependencies
      - name: Install watchdog dependencies
        working-directory: watchdog
        shell: pwsh
        run: |
          Write-Host "Installing watchdog dependencies..."

          # Get VS path
          $vsPath = & vswhere.exe -latest -property installationPath
          Write-Host "VS Installation Path: $vsPath"

          # Initialize VS environment
          $vcvarsPath = Join-Path $vsPath "VC\Auxiliary\Build\vcvars64.bat"
          Write-Host "Initializing VS environment..."

          # Find Windows SDK paths
          $sdkBase = "C:\Program Files (x86)\Windows Kits\10"
          $sdkPlatform = $null
          $sdkReferences = $null
          $sdkWindows = $null

          # Find SDK References
          if (Test-Path "$sdkBase\References") {
              $refDirs = Get-ChildItem "$sdkBase\References" -Directory | Sort-Object Name -Descending
              foreach ($dir in $refDirs) {
                  if (Test-Path "$($dir.FullName)\Windows.Foundation.UniversalApiContract") {
                      $sdkReferences = $dir.FullName
                      Write-Host "Found SDK References: $sdkReferences"
                      break
                  }
              }
          }

          # Find platform.winmd and Windows.winmd in UnionMetadata
          if (Test-Path "$sdkBase\UnionMetadata") {
              $unionDirs = Get-ChildItem "$sdkBase\UnionMetadata" -Directory | Sort-Object Name -Descending
              foreach ($dir in $unionDirs) {
                  if (Test-Path "$($dir.FullName)\platform.winmd") {
                      $sdkPlatform = $dir.FullName
                      Write-Host "Found SDK Platform: $sdkPlatform"
                      break
                  }
              }
          } else {
              Write-Host "WARNING: UnionMetadata folder not found"
          }

          # Fallback 2: Try VS installation Common7\IDE\VC\vcpackages
          if (-not $sdkPlatform) {
              $vcPackagesPath = Join-Path $vsPath "Common7\IDE\VC\vcpackages\platform.winmd"
              if (Test-Path $vcPackagesPath) {
                  Write-Host "WARNING: Using VS vcpackages folder"
                  $sdkPlatform = Split-Path $vcPackagesPath -Parent
                  
                  # Find Windows.winmd separately
                  $winmdFile = Get-ChildItem -Path $sdkBase -Filter "Windows.winmd" -Recurse -ErrorAction SilentlyContinue | 
                      Where-Object { $_.DirectoryName -match 'UnionMetadata' } | 
                      Select-Object -First 1
                  
                  if ($winmdFile) {
                      $sdkWindows = $winmdFile.DirectoryName
                      Write-Host "Found Windows.winmd at: $sdkWindows"
                  } else {
                      Write-Host "WARNING: Could not find Windows.winmd"
                  }
              }
          }

          # Fallback 3: Try VS Tools MSVC
          if (-not $sdkPlatform) {
              $msvcPlatform = Get-ChildItem -Path "$vsPath\VC\Tools\MSVC" -Filter "platform.winmd" -Recurse -ErrorAction SilentlyContinue | 
                  Where-Object { $_.DirectoryName -match 'lib\\x64\\store\\references' } | 
                  Sort-Object FullName -Descending | 
                  Select-Object -First 1
              
              if ($msvcPlatform) {
                  $sdkPlatform = $msvcPlatform.DirectoryName
                  Write-Host "Found SDK Platform in VS Tools: $sdkPlatform"
              }
          }

          if (-not $sdkPlatform) {
              Write-Host "ERROR: Could not find platform.winmd"
              exit 1
          }

          # Build SDK paths list
          $sdkPaths = @($sdkPlatform)
          if ($sdkReferences) { $sdkPaths += $sdkReferences }
          if ($sdkWindows) { $sdkPaths += $sdkWindows }

          $sdkPathsStr = $sdkPaths -join ';'
          Write-Host "SDK Paths: $sdkPathsStr"

          # Set npm config
          npm config set msvs_version 2022
          npm config set msbuild_path "$vsPath\MSBuild\Current\Bin\MSBuild.exe"

          # Set environment variables for the build
          $env:GYP_MSVS_VERSION = "2022"
          $env:GYP_DEFINES = "target_arch=x64"
          $env:LIBPATH = "$sdkPathsStr;$env:LIBPATH"
          $env:INCLUDE = "$sdkPathsStr;$env:INCLUDE"
          $env:LIB = "$sdkPathsStr;$env:LIB"

          # Build CL flags
          $clFlags = $sdkPaths | ForEach-Object { "/AI`"$_`"" }
          $env:CL = $clFlags -join ' '
          Write-Host "CL flags: $env:CL"

          # Run vcvars64.bat to set up VS environment, then install npm packages
          # We need to do this in a way that preserves the environment
          $tempBat = [System.IO.Path]::GetTempFileName() + ".bat"
          $tempEnv = [System.IO.Path]::GetTempFileName()

          @"
          @echo off
          call "$vcvarsPath"
          set GYP_MSVS_VERSION=2022
          set GYP_DEFINES=target_arch=x64
          set LIBPATH=$sdkPathsStr;%LIBPATH%
          set INCLUDE=$sdkPathsStr;%INCLUDE%
          set LIB=$sdkPathsStr;%LIB%
          set CL=$env:CL
          call npm install --production
          if errorlevel 1 exit /b 1
          set > "$tempEnv"
          "@ | Out-File -FilePath $tempBat -Encoding ASCII

          Write-Host "Running npm install with VS environment..."
          $result = & cmd /c $tempBat

          if ($LASTEXITCODE -ne 0) {
              Remove-Item $tempBat -ErrorAction SilentlyContinue
              Remove-Item $tempEnv -ErrorAction SilentlyContinue
              Write-Host "ERROR: Failed to install watchdog dependencies"
              exit 1
          }

          Remove-Item $tempBat -ErrorAction SilentlyContinue
          Remove-Item $tempEnv -ErrorAction SilentlyContinue

          Write-Host "Watchdog dependencies installed successfully!"

      # 10. Rebuild native modules
      - name: Rebuild Native Modules
        working-directory: app
        shell: cmd
        run: |
          REM Set VS path for node-gyp
          for /f "usebackq delims=" %%i in (`vswhere.exe -latest -property installationPath`) do set "VS_PATH=%%i"

          echo VS Installation Path: %VS_PATH%

          REM Initialize VS environment
          call "%VS_PATH%\VC\Auxiliary\Build\vcvars64.bat"
          if errorlevel 1 (
            echo ERROR: Failed to initialize VS environment
            exit /b 1
          )

          REM Set npm config for VS
          npm config set msvs_version 2022
          npm config set msbuild_path "%VS_PATH%\MSBuild\Current\Bin\MSBuild.exe"

          echo Starting electron-rebuild...
          REM Rebuild with explicit VS path
          npx electron-rebuild --force --debug --ms-build-path="%VS_PATH%\MSBuild\Current\Bin\MSBuild.exe"
          if errorlevel 1 (
            echo ERROR: electron-rebuild failed
            exit /b 1
          )

          echo Native module rebuild completed successfully!

      # 11. Cache Electron headers
      - name: Cache Electron headers
        uses: actions/cache@v4
        with:
          path: ~/.electron
          key: electron-headers-${{ runner.os }}-12.2.3

      # 12. Fetch all tags and history for version comparison
      - name: Fetch tags and history
        shell: pwsh
        run: |
          # Fetch with unshallow, suppress errors if already complete
          try {
            git fetch --tags --force --unshallow
          } catch {
            git fetch --tags --force
          }

          Write-Host "Available tags:"
          git tag -l

          Write-Host "`nRecent commits:"
          git log --oneline -10

      # 13. Get version and generate release notes
      - name: Get version and generate release notes
        id: get_version
        shell: pwsh
        run: |
          # Read current package.json version as fallback
          $pkg = Get-Content -Raw app\package.json | ConvertFrom-Json
          $fallbackVersion = $pkg.version
          Write-Host "Package.json version: $fallbackVersion"

          # Get the latest release version
          $headers = @{
            'Authorization' = 'token ${{ secrets.REGISTRY_TOKEN }}'
            'Accept' = 'application/vnd.github.v3+json'
          }

          try {
            $latestRelease = Invoke-RestMethod -Uri "https://api.github.com/repos/${{ github.repository }}/releases/latest" -Headers $headers
            $lastVersion = $latestRelease.tag_name
            $lastTag = $lastVersion
            Write-Host "Last release tag: $lastTag"
            
            # Strip 'v' prefix if present for version comparison (backwards compatibility)
            $lastVersionNumber = $lastVersion -replace '^v', ''
            Write-Host "Last release version (normalized): $lastVersionNumber"
          } catch {
            Write-Host "No previous release found, using package.json version as base"
            $lastVersionNumber = $fallbackVersion
            $lastTag = $null
          }

          # Parse version and increment patch
          if ($lastVersionNumber -match '^(\d+)\.(\d+)\.(\d+)') {
            $major = [int]$matches[1]
            $minor = [int]$matches[2]
            $patch = [int]$matches[3]
            $patch++
            $newVersion = "$major.$minor.$patch"
          } else {
            # Fallback to package.json version
            $newVersion = $fallbackVersion
          }

          Write-Host "New version: $newVersion (will be tagged as v$newVersion)"
          Write-Output "version=$newVersion" >> $env:GITHUB_ENV
          Write-Output "NEW_VERSION=$newVersion" >> $env:GITHUB_OUTPUT

          # Generate commit log since last release
          $commitLog = ""
          if ($lastTag) {
            Write-Host "Getting commits since $lastTag..."
            
            # Check if tag exists locally
            $tagExists = git tag -l $lastTag
            if ($tagExists) {
              # Get commits including merges to capture upstream changes
              $commits = git log "$lastTag..HEAD" --pretty=format:"- %s (%h)" 2>&1
              
              if ($LASTEXITCODE -eq 0 -and $commits -and $commits -notmatch "fatal|error") {
                # Split commits into array and filter out empty lines
                $commitArray = ($commits -split "`n") | Where-Object { $_ -and $_.Trim() }
                $commitCount = $commitArray.Count
                
                if ($commitCount -gt 10) {
                  # Limit to 10 commits
                  $commitLog = "## ðŸŽ‰ What's Changed`n`n"
                  $commitLog += ($commitArray | Select-Object -First 10) -join "`n"
                  $remaining = $commitCount - 10
                  $commitLog += "`n`n_...and $remaining more commit(s)_"
                } elseif ($commitCount -gt 0) {
                  $commitLog = "## ðŸŽ‰ What's Changed`n`n" + ($commitArray -join "`n")
                } else {
                  $commitLog = "## ðŸŽ‰ What's Changed`n`n- No new commits since last release"
                }
                
                Write-Host "Found $commitCount commit(s)"
              } else {
                Write-Host "WARNING: Could not get commit log, tag might not exist in history"
                $commitLog = "## ðŸŽ‰ What's Changed`n`n- See commit history for changes since $lastTag"
              }
            } else {
              Write-Host "WARNING: Tag $lastTag not found locally"
              $commitLog = "## ðŸŽ‰ What's Changed`n`n- See commit history for changes since $lastTag"
            }
          } else {
            $commitLog = "## ðŸŽ‰ What's Changed`n`n- Initial release"
          }

          # Add full changelog link
          if ($lastTag) {
            $commitLog += "`n`n**Full Changelog**: https://github.com/${{ github.repository }}/compare/$lastTag...v$newVersion"
          }

          # Save commit log to file for use in release body
          $commitLog | Out-File -FilePath commit_log.txt -Encoding UTF8
          Write-Host "Commit log saved"

      # 13. Update package.json version
      - name: Update package.json version
        shell: pwsh
        run: |
          Write-Host "Updating package.json version to ${{ env.version }}"
          $pkgPath = "app\package.json"
          $pkg = Get-Content -Raw $pkgPath | ConvertFrom-Json
          $pkg.version = "${{ env.version }}"
          $pkg | ConvertTo-Json -Depth 100 | Set-Content $pkgPath -Encoding UTF8
          Write-Host "Package.json updated successfully"

      # 14. Build Windows installer
      - name: Build installer
        working-directory: app
        env:
          DEBUG: electron-builder
          DEBUG_COLORS: 1
        run: npx electron-builder --windows --publish never

      # 15. Create GitHub Release
      - name: Create GitHub Release
        id: create_release
        uses: actions/create-release@v1
        with:
          tag_name: v${{ env.version }}
          release_name: Release v${{ env.version }}
          body_path: commit_log.txt
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.REGISTRY_TOKEN }}

      # 14. Upload installer to release
      - name: Upload installer
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: app/dist/Achievement.Watcher.Setup.${{ env.version }}.exe
          asset_name: Achievement.Watcher.Setup.${{ env.version }}.exe
          asset_content_type: application/octet-stream

      # 15. Upload latest.yml
      - name: Upload latest.yml
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: app/dist/latest.yml
          asset_name: latest.yml
          asset_content_type: application/octet-stream

      # 16. Upload blockmap
      - name: Upload blockmap
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.REGISTRY_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: app/dist/Achievement.Watcher.Setup.${{ env.version }}.exe.blockmap
          asset_name: Achievement.Watcher.Setup.${{ env.version }}.exe.blockmap
          asset_content_type: application/octet-stream
